[{"content":"Why do we need to evaluate LLMs? It is a well known fact in the LLM world that evaluating large language models is no easy task. It\u0026rsquo;s something that researchers are still trying to perfect even today. For the end user specifically, creating LLM applications that deliver value is of utmost importance and as developers we need to understand how to measure that value. Josh Tobin, an OpenAI researcher, explains that with the advent of generative AI, anyone can create an MVP within 15 minutes. From then on, a lot of people underestimate the amount of effort required to convert that MVP into a full fledged product. Robust evaluation processes are needed to create reliable production ready LLM systems that are much more than just a simple rudimentary prototype.\nWhy is it so hard to evaluate LLMs? The main issue with evaluating LLM outputs or any kind of generative AI output is that there really isn\u0026rsquo;t any kind of \u0026ldquo;right\u0026rdquo; or \u0026ldquo;wrong\u0026rdquo; answer. Take for example, describing what a Golden Retriever looks like. Objectively yes, there is a baseline requirement for a dog\u0026rsquo;s basic features to be there but an LLM can output two different descriptions of a Golden Retriever which can be accurate. The question here is how would we quantify which of the two descriptions is better? Moreover, with a diverse set of outputs, some cases might be considered right in some scenarios and wrong in others.\nSo\u0026hellip; what do we do?\nIntroducing Benchmarking! Since the beginning of time, we\u0026rsquo;ve evaluated human performance through standardised tests like the SATs or GREs so why can\u0026rsquo;t we employ that for evaluating LLMs? Well, benchmarking does just that.\nBenchmarking simply refers to standardised software performance tests. Most language model benchmarks are based on specific NLP tasks from which we can get a numeric result. This is great because it solves the problem of being unable to quantitatively measure qualitative tasks.\nThere are five main categories to benchmarking:\n Functional Correctness Live Human Eval Models evaluating models Task-specific performance Matching human answers  I\u0026rsquo;ll explain each category and a corresponding example.\nFunctional Correctness This benchmark is mostly used for evaluating downstream tasks where we check if the output is actually solving the problem we want it to solve. This covers problems with definite outputs so areas like code completion. Eg:- HumanEval,StaticEval\nHumanEval It is an evaluation dataset containing 164 original programming problems that measure the functional correctness of code. These problems assess language comprehension, algorithms, and simple mathematics, with some comparable to simple software interview questions.\nHere\u0026rsquo;s what the problems look like:\nIt is primarily used for evaluating the task of converting detailed docstrings into code popularly done by Codex, a GPT language model finetuned on publicly available code from GitHub, and studying its Python code-writing capabilities.\nIt uses a metric called pass@k which is a probability of getting at least one output right out of k samples that a prompt generates. If k = 10, the prompt would be directed to generate 10 samples out of which we will check if any one sample passes the unit tests. So, pass@10 = 0.5 that means 50% of the user prompts generated at least one sample of code that successfully passed unit tests out of the 10 samples generated.\nLive Human Eval This benchmark refers to evaluating LLMs through active human feedback that may translate to a thumbs up/thumbs down to an LLM output or rating an LLM response from 1-5. Eg:- Chatbot Arena,HALIE\nHALIE Human-AI Language-based Interaction Evaluation or HALIE is an evaluation framework that defines the components of human-LM interactive systems and evaluation metrics, putting interaction at the center of LM evaluation.\nInteractive evaluation lies at the heart of this framework focusing on interactions between the user and a system. A system consists of a language model (LM), a user interface (UI), and a system logic which constructs prompts and invokes the LM. HALIE formally defines the system logic with states and actions. A state of the system refers to the textual contents in the UI (e.g., dialogue history and the current text in a user input box), and an action is taken by a user (e.g., clicking the “send” button or typing into a text box) through the UI, which subsequently triggers the system to update the state.\nThe tasks involved in HALIE are\n Social Dialogue Question Answering Crossword Puzzle Text Summarization Metaphor Generation  For this framework, let\u0026rsquo;s dive into the task of text summarization in detail.\nTask This task involves human-LM interaction for single-document summarization, where users interact with the system to correct LM-generated summaries. Given a document and a model-generated summary, users edit the summary to be consistent, relevant, and coherent. They randomly selected 964 documents from the XSum dataset and constructed 20 summarization sessions by randomly choosing ten documents per session without replacement.\n System State - document, user summary history, user input, and survey questions. System Action - Responding to the survey questions and clicking the next button after filling in the survey responses.  Metrics To understand the metrics they used to evaluate this task, let\u0026rsquo;s look at a user study.\n39 crowd workers (or users) on Amazon Mechanical Turk were recruited. For each model, they collected 20 summarization sessions (80 in total), while allowing the same users to participate multiple times. Upon receiving a model-generated summary for each document, users were asked to edit the summary to be consistent, relevant, and coherent. Users were asked to evaluate the consistency, relevance, and coherence of the original (model-generated) summary and edited summary before and after editing. At the end of a summarization session, users completed a survey about their overall experience interacting with the system.\nThe survey involved the following kinds of questions [The 5-point Likert metric refers to the user choosing one of the five options - Strongly Agree, Agree, Neutral, Disagree, Strongly Disagree]:\n Helpfulness (5-point Likert): How helpful was having access to the AI assistant as an automated summarization tool? Edit amount (5-point Likert): How much did you have to edit the generated summaries? Improvement (5-point Likert): The AI assistant improved as I edited more summaries.  At the end, here\u0026rsquo;s what the metrics look like\nUsers edited summaries generated by TextBabbage the most, and TextDavinci the least. Overall, users perceived TextDavinci to be most helpful (helpfulness) and better improves over time (improvement) compared to the other models. The first three metrics refer to the length of model-generated summaries (original), human-edited summaries (edited), and the Levenshtein distance between them (edit distance). The numbers indicate means and standard errors, and the markers denote statistical significance.\nTo note, Levenshtein distance refers to the smallest number of single-character modifications (insertions, deletions, or substitutions) required to transform one word into the other. For example, the Levenshtein distance between the words can and tap is 2.\n can \u0026ndash;\u0026gt; tan [1 modification] tan \u0026ndash;\u0026gt; tap [1 modification]  So, if the distance is high, that reflects more inaccuracy between the human edited summary and the model generated summary.\nModels evaluating models This might be counterintuitive but for certain tasks like language translation and abstractive summarization, LLMs are great at evaluating other LLMs. An LLM is prompted to act like an evaluator and evaluates other model against reference outputs. Eg:-AlpacaEval, GEMBA\nAlpacaEval AlpacaEval is an LLM-based automatic evaluation that is fast, cheap, replicable, and validated against 20K human annotations. It is based on the AlpacaEval dataset which contains something like this:\n { \u0026quot;dataset\u0026quot;: \u0026quot;helpful_base\u0026quot;, \u0026quot;instruction\u0026quot;: \u0026quot;What are the names of some famous actors that started their careers on Broadway?\u0026quot;, \u0026quot;output\u0026quot;: \u0026quot;Some famous actors that started their careers on Broadway include: \\n1. Hugh Jackman \\n2. Meryl Streep \\n3. Denzel Washington \\n4. Julia Roberts \\n5. Christopher Walken \\n6. Anthony Rapp \\n7. Audra McDonald \\n8. Nathan Lane \\n9. Sarah Jessica Parker \\n10. Lin-Manuel Miranda\u0026quot;, \u0026quot;generator\u0026quot;: \u0026quot;text_davinci_003\u0026quot; }, { \u0026quot;dataset\u0026quot;: \u0026quot;helpful_base\u0026quot;, \u0026quot;instruction\u0026quot;: \u0026quot;How did US states get their names?\u0026quot;, \u0026quot;output\u0026quot;: \u0026quot;US states get their names from a variety of sources, including Native American tribes, Spanish explorers, British colonists, and even presidents. For example, the state of Alabama was named after the Native American tribe that lived in the area, while the state of Florida gets its name from the Spanish explorer, Ponce de Leon, who explored the area in the 1500s. Other states are named after English kings (like Virginia, named after England's \\\u0026quot;Virgin Queen,\\\u0026quot; Queen Elizabeth I) or presidents (like Washington, named after George Washington).\u0026quot;, \u0026quot;generator\u0026quot;: \u0026quot;text_davinci_003\u0026quot; }, { \u0026quot;dataset\u0026quot;: \u0026quot;helpful_base\u0026quot;, \u0026quot;instruction\u0026quot;: \u0026quot;Hi, my sister and her girlfriends want me to play kickball with them. Can you explain how the game is played, so they don't take advantage of me?\u0026quot;, \u0026quot;output\u0026quot;: \u0026quot;Kickball is a game similar to baseball, but with a large rubber ball instead of a bat and a ball. The game is usually played with two teams of six players each. Each team has three bases and a home plate. The players on the kicking team line up at home plate and take turns kicking the ball. The object of the game is to score runs by running around all three bases and back to home plate without being tagged out by the defense. The team with the most runs at the end of the game is the winner.\u0026quot;, \u0026quot;generator\u0026quot;: \u0026quot;text_davinci_003\u0026quot; } AlpacaEval outputs a leaderboard containing the performance of the desired model against a reference model (text-davinci-003) evaluated by an LLM acting as an automatic evaluator. The following leaderboard contains a list of models with their win rates evaluated by alpaca_eval_gpt4.\nalpaca_eval_gpt4 minimal leaderboard:\n   Model Win Rate Std Error     gpt4 95.3 0.7   claude 88.4 1.1   chatgpt 86.1 1.2   wizardlm-13b 75.3 1.5   guanaco-65b 71.8 1.6   vicuna-13b 70.4 1.6   oasst-rlhf-llama-33b 66.5 1.7   text_davinci_003 50.0 0.0   falcon-40b-instruct 45.7 1.8   alpaca-farm-ppo-human 41.2 1.7   alpaca-7b 26.5 1.5   text_davinci_001 15.2 1.2    The win rate measures the fraction of time the model\u0026rsquo;s output is preferred over text-davinci-003 outputs ( i.e. the reference). More specifically, to compute the win rate they collected pairs of outputs of the desired model on every instruction from the AlpacaEval dataset. They then pair each output with the output of the reference model (text-davinci-003) on the same instruction and ask the automatic evaluator which output it prefers.\nThe alpaca_eval_gpt4 annotator averages over preferences, where preferences are obtained as follows:\n it takes in an instruction and a pair of outputs (from the desired model and the reference model) if a preference was already computed, it returns it (i.e. it uses caching) it randomizes the order of the outputs to avoid position bias it formats the instruction and outputs into the following zero-shot prompt, which asks to order the outputs in order of preference it completes the prompt using GPT4 with temperature=0 it parses the preference from the completions and returns it  The alpaca_eval_gpt4 is prompted to act like an evaluator and its effectiveness is measured by comparing it to 2.5k human annotations which look like this:\n { \u0026quot;instruction\u0026quot;:\u0026quot;The sentence you are given might be too wordy, complicated, or unclear. Rewrite the sentence and make your writing clearer by keeping it concise. Whenever possible, break complex sentences into multiple sentences and eliminate unnecessary words.\\n\\nIf you have any questions about my rate or if you find it necessary to increase or decrease the scope for this project, please let me know.\u0026quot;, \u0026quot;output_1\u0026quot;:\u0026quot;If you have questions about my rate or need to modify the scope of this project, please let me know.\u0026quot;, \u0026quot;output_2\u0026quot;:\u0026quot;If you have any questions about my rate or need to adjust the scope for this project, please let me know.\u0026quot;, \u0026quot;preference\u0026quot;:1, \u0026quot;annotator_index\u0026quot;:15, \u0026quot;dataset\u0026quot;:\u0026quot;selfinstruct\u0026quot;, \u0026quot;datasplit\u0026quot;:\u0026quot;eval\u0026quot; } The following metrics are used to measure evaluators:\n    Human agreement [%] Price [$/1000 examples] Time [seconds/1000 examples] Bias Variance Proba. prefer longer     alpaca_eval_gpt4_fn 71.0 14.5 5046 27.6 11.1 0.75   alpaca_eval_gpt4 69.2 13.6 1455 28.4 14.6 0.68   aviary_gpt4 69.1 12.8 1869 29.5 13.1 0.70   gpt4 66.9 12.5 1037 31.5 14.6 0.65   alpaca_farm_greedy_gpt4 66.4 15.3 878 30.2 19.3 0.60   humans 65.7 300.0 36800 0.0 34.3 0.64   claude 65.5 11.1 173 31.9 18.0 0.62   text_davinci_003 64.1 8.7 121 33.8 22.7 0.70   lmsys_gpt4 63.2 13.9 17982 34.7 16.1 0.74   chatgpt_fn 60.0 1.0 530 36.9 27.7 0.62   chatgpt 57.2 0.8 285 39.4 34.1 0.59     Human Agreement - This measures the agreement between the current annotator and the majority preferences of humans on the ~650 annotations from the cross-annotation set, which contains 4 human annotations per example. To estimate the agreement between a single human (humans row in the table above) and the majority of humans, we take one of the 4 annotations and compute the accuracy that it has when predicting the mode of the other 3 annotations. We then average this accuracy over all 4 annotations and over the 650 instructions to get the human agreement. Price - This is the average price of every 1000 annotations. Time - This is the average time it takes to compute 1000 annotations i.e. the average time that it took when running the annotations. Bias - Agreement between the most likely human label and the most likely automatic one. A low bias means that the annotator has in expectation the same preferences as humans. For the case of humans, the bias is zero by definition. Variance - Expected agreement a single automatic preference and the most likely one. A low variance means that the annotator is consistent with its preference, i.e., if you sample from it with different seeds it will give the same result.  Task specific performance Benchmarks that test the LLM output through a particular task or scenario like question answering, metaphor generation or summarization. Eg:- HeLM, MMLU, SuperGlue\nHeLM Holistic Evaluation of Language Models or HeLM is a benchmark that evaluates prominent language models across a wide range of scenarios from question answering to summarization to toxicity detection. It has three main features:\n Broad coverage and recognition of incompleteness - Given language models’ vast surface of capabilities and risks, we need to evaluate language models over a broad range of scenarios. However, it is not possible to consider all the scenarios, so holistic evaluation should make explicit all the major scenarios and metrics that are missing. Multi-metric measurement - Most existing benchmarks consider scenarios with a single main metric (usually accuracy), relegating the evaluation of other desiderata (e.g., toxicity) to separate scenarios. Holistic evaluation should represent these plural desiderata. Standardization - The object of evaluation is the language model, not a scenario-specific system. Therefore, in order to meaningfully compare different LMs, the strategy for adapting an LM to a scenario should be controlled for. Further, we should evaluate all the major LMs on the same scenarios to the extent possible.  The above image contains information (you can click on the word you want to know more about) about every model, scenario and metric that HeLM uses to evaluate an LLM.\nFor example, let\u0026rsquo;s take a question answering scenario which uses the MMLU benchmark to evaluate the gpt-2 model. To note, the MMLU or Massive Multitask Language Understanding is a benchmark for knowledge-intensive question answering across 57 domains like science, philosophy etc.\nWe first create a run_specs.conf file which includes information about the kind of benchmark we want to use, domain and model we want to evaluate.\necho 'entries: [{description: \u0026quot;mmlu:subject=philosophy,model=huggingface/gpt2\u0026quot;, priority: 1}]' \u0026gt; run_specs.conf Then, we run HeLM on that benchmark on 10 instances and summarise those results.\nhelm-run --conf-paths run_specs.conf --suite v1 --max-eval-instances 10 helm-summarize --suite v1 We start a web server to view the eval results.\nhelm-server As you can see, the model was able to answer one of the questions correctly but answered most of them wrong with the exact_match metric being 0.111\nMatching human answers The basic way to evaluate LLMs is to compare the LLM generated output with a human generated output which benchmarks like BLEU and ROUGE does.\nBLEU Bilingual Evaluation Understudy or BLEU is a metric used to evaluate the quality of machine-generated translations against one or more reference translations. It measures the similarity between the machine-generated translation and the reference translations based on the n-grams (contiguous sequences of n words) present in both. A higher BLEU score indicates more overlap between the generated and reference translations.\nfrom collections import Counter import nltk.translate.bleu_score as bleu def calculate_BLEU(generated_summary, reference_summary, n): # Tokenize the generated summary and reference summary generated_tokens = generated_summary.split() reference_tokens = reference_summary.split() # Calculate the BLEU score weights = [1.0 / n] * n # Weights for n-gram precision calculation bleu_score = bleu.sentence_bleu([reference_tokens], generated_tokens, weights=weights) return bleu_score # Example usage generated_summary = \u0026quot;The dog slept on the couch.\u0026quot; reference_summary = \u0026quot;The cat sat on the mat.\u0026quot; n = 2 # Bigram bleu_score = calculate_BLEU(generated_summary, reference_summary, n) print(f\u0026quot;BLEU-{n} score: {bleu_score}\u0026quot;) The output is 0.37 indicating that there isn\u0026rsquo;t too much similarity between both sentences.\nHowever, BLEU has its disadvantages. An incorrect translation can still recieve a high score. For example, if we take the following two summaries:\n generated_summary = \u0026ldquo;The dog slept on the couch.\u0026rdquo; reference_summary = \u0026ldquo;The The The The The\u0026rdquo;  This will give be a perfect score of 1, since the word \u0026ldquo;The\u0026rdquo; exists in both summaries even though it isn\u0026rsquo;t a correct translation. Additionally, BLEU cannot evaluate the importance of errors. For a BLEU score, an error is just that: an error. In real life, if a word is placed incorrectly within a sentence, it can change its entire meaning. A very low score does generally reliably indicate that a translation is of poor quality, but a high score can also simply be the result of an error in the system.\nHence, the best scenario to use BLEU is to answer the question, \u0026ldquo;Is our current system better than the old one?\u0026rdquo;\nReferences  https://arxiv.org/pdf/2212.09746.pdf https://crfm.stanford.edu/2022/11/17/helm.html https://github.com/tatsu-lab/alpaca_eval/tree/main https://crfm-helm.readthedocs.io/en/latest/quick_start/ https://deepgram.com/learn/humaneval-llm-benchmark https://deepgram.com/learn/mmlu-llm-benchmark-guide  ","date":"2023-10-07T14:45:50+05:30","image":"https://anoura12.github.io/blog/p/evaluating-llms-part-i-benchmarking-strategies/benchmark_hud92999e3732ffdcbfc80e9ee8e303856_39478_120x120_fill_q75_box_smart1.jpg","permalink":"https://anoura12.github.io/blog/p/evaluating-llms-part-i-benchmarking-strategies/","title":"Evaluating LLMs Part I - Benchmarking Strategies"},{"content":"Employing LLMs to do what we want is now possible through prompting and finetuning. For specific downstream tasks, we can finetune the LLM on our own custom dataset to generate the outputs that we want. However, finetuning is computationally expensive requiring GPUs to train these LLMs so most of the times, we can\u0026rsquo;t finetune LLMs using just our computer.\nAndrej Karpathy from OpenAI created a simple framework called nanoGPT that enables you to train and finetune medium sized GPTs. It gives you an interesting insight into how a GPT works and allows you to use your custom dataset to train these models. His video on building a GPT from scratch, breaks down the concepts of a GPT\u0026rsquo;s architecture and what really goes on under the hood.\nBeing an avid fan of Agatha Christie\u0026rsquo;s Hercule Poirot mystery series, I decided to train and finetune a GPT to generating text that somewhat resembles her writing and enjoy reading a never seen before mystery story in the hand of Agatha Christie!\nTraining There are three stages to producing a piece of text through training a GPT on your dataset in nanoGPT\n Prepare Train Sample  Prepare This stage involves loading your dataset (in this case, a text file) and creating tokens through the OpenAI BPE tokeniser called tiktoken. For the dataset, I used Agatha Christie\u0026rsquo;s Poirot Investigates book which is a series of 8 short murder mystery stories.\nI initially thought of getting one of her novels which contained one mystery and inputting that into the model directly for training however, that didn\u0026rsquo;t work out so well. Choosing a list of short stories which contains a mystery from start to end would give the model several examples of her writing in a short dataset which would be more feasible than working with several novels for our experiment.\nFor every new dataset, we need to create a prepare.py file which ultimately divides the tokens into training(train.bin) and validation (val.bin) data. I stored the file under a folder called agatha in the data folder.\nimport os import requests import tiktoken import numpy as np input_file_path = os.path.join(os.path.dirname(_file_), 'poirot.txt') with open(input_file_path, 'r') as f: data = f.read() n = len(data) train_data = data[:int(n*0.9)] val_data = data[int(n*0.9):] # encode with tiktoken gpt2 bpe enc = tiktoken.get_encoding(\u0026quot;gpt2\u0026quot;) train_ids = enc.encode_ordinary(train_data) val_ids = enc.encode_ordinary(val_data) print(f\u0026quot;train has {len(train_ids):,} tokens\u0026quot;) print(f\u0026quot;val has {len(val_ids):,} tokens\u0026quot;) # export to bin files train_ids = np.array(train_ids, dtype=np.uint16) val_ids = np.array(val_ids, dtype=np.uint16) train_ids.tofile(os.path.join(os.path.dirname(_file_), 'train.bin')) val_ids.tofile(os.path.join(os.path.dirname(_file_), 'val.bin')) To run the prepare.py file, run this command.\npython data/agatha/prepare.py You should get something like this after running the command\nTrain Next, we train the model on the training data by running this command.\npython train.py config/train_poirot.py So, as you can see there are two files in question here - the train.py and train_poirot.py files.\nThe train.py file defines a set of parameters and the code dependent on the kind of device (cpu, cuda, mps etc.) you\u0026rsquo;re using. For this experiment, I used a single NVIDIA GPU to run around 5000 iterations for training the model. The training process involves the following steps:\n Fetch the first batch of data (batch_size = 32) Set the learning rate Evaluate loss Capture checkpoints which is done everytime the loss decreases Perform a forward backward pass (update the model)  The train_poirot.py file is a neat way to store all the parameters that are set to your custom values that override the default values in train.py. Here\u0026rsquo;s what the main parameters mean:\n gradient_accumulation_steps - This is the number of batches after which a gradient update should happen. batch_size - This refers to the number of data samples processed in one forward pass block_size - This refers to the context length. The longer the context length, the more computationally expensive it will get. n_layer - The number of layers in the model, more the layers more complex is your model n_head - The number of attention heads in the multi-layer attention part of the transformer n_embd - The dimensionality of embedding vectors, higher the value, higher the complexity dropout - Helps prevent overfitting by setting a number of inputs to zero. So, a dropout value of 0.2 refers to 20% of the input values being zero. learning rate - Step-size at which model\u0026rsquo;s parameters are updated max_iters - Maximum number of iterations which the model is trained on  out_dir = 'out-poirot' eval_interval = 250 # keep frequent because we'll overfit eval_iters = 200 log_interval = 10 # don't print too too often # we expect to overfit on this small dataset, so only save when val improves always_save_checkpoint = False wandb_log = False # override via command line if you like wandb_project = 'agatha' wandb_run_name = 'mini-gpt' dataset = 'agatha' gradient_accumulation_steps = 1 batch_size = 32 block_size = 256 # context of up to 256 previous characters # baby GPT model :) n_layer = 6 n_head = 6 n_embd = 384 dropout = 0.2 learning_rate = 1e-3 # with baby networks can afford to go a bit higher max_iters = 5000 lr_decay_iters = 5000 # make equal to max_iters usually min_lr = 1e-4 # learning_rate / 10 usually beta2 = 0.99 # make a bit bigger because number of tokens per iter is small warmup_iters = 100 # not super necessary potentially This is how the training process looks like. mfu stands for Memory Footprint Utilisation which indicates the amount of memory used for each iteration of the training process as a percentage.\nSample This stage involves generating the text after the model has been trained. The file also conatins majority of the code defined in train.py except for the following piece of code. It refers to the checkpoint contained in out-poirot to generate text.\n# encode the beginning of the prompt if start.startswith('FILE:'): with open(start[5:], 'r', encoding='utf-8') as f: start = f.read() start_ids = encode(start) x = (torch.tensor(start_ids, dtype=torch.long, device=device)[None, ...]) # run generation with torch.no_grad(): with ctx: for k in range(num_samples): y = model.generate(x, max_new_tokens, temperature=temperature, top_k=top_k) print(decode(y[0].tolist())) print('---------------') To generate text, run this command.\npython sample.py --out_dir=out-poirot Annddd this is the output\n'And that I'd got to have been belant is that I should be really to hurry over, Hastings, but he was no. I am have the mysterious man, my friend.' The little bottle to take a lady's nurse, and the stairs. He is no further supply into the disaster. In a 'I didn't it wasps'But I ami. It's death, eh, I was likely to scorn, Lady Juliet your mind. She was a little husband's a moment! But they feel partly and not yet my little affair on the garden, you reply. She, but I was a sharp face waspsâ€” and her husband, the window. evening, however, madame, you know that she friend, Monsieurier's eight, but no time, there was on one, I knew that she slipped to be tired. He is the paper for your time, though she had never just for you say, the smoking-five and a moustache. I knew window, did not be the boy to see her, and left the library. to see, Poirot. He But it somewhere.' 'I know this evening.' It doesn\u0026rsquo;t make a lot of sense but the words themselves sort of resemble her writing?\nLet\u0026rsquo;s try to do better with finetuning.\nFinetuning The process for finetuning remains the same except this time we refer to a different set of parameters defined in finetune_poirot.py. In this file, we load an existing pretrained model (gpt2-large - 776 million params!) and finetune that to our usecase.\nimport time out_dir = 'out-poirot' eval_interval = 5 eval_iters = 40 wandb_log = False # feel free to turn on wandb_project = 'agatha' wandb_run_name = 'ft-' + str(time.time()) dataset = 'agatha' init_from = 'gpt2-large' # this is the largest GPT-2 model # only save checkpoints if the validation loss improves always_save_checkpoint = False batch_size = 1 gradient_accumulation_steps = 32 max_iters = 10 # finetune at constant LR learning_rate = 3e-5 decay_lr = False To run this file, we use the following command.\npython train.py config/finetune_poirot.py This took a lot longer than expected and I managed to get 10 iterations out of it\nNext, we define a prompt.txt file which is converted to embeddings in the sample.py file. Initially, I used the following prompt - In the style of Agatha Christie, craft a short story where an unexpected guest at a remote country estate dinner party ends up murdered, leaving the guests to unravel the secrets and motives hidden among them.\nIt got me some pretty silly results\nSo, I tweaked the prompt so that the model generates text that continues the story. The prompt starts like this-\nTitle: \u0026quot;The Enigmatic Garden Murder\u0026quot; In the sleepy village of Willowbrook, nestled amidst rolling hills and lush greenery, a group of friends gather for their annual garden party. Lady Margaret Hastings, the elegant hostess known for her exquisite rose garden, has invited her closest friends and neighbors to revel in the beauty of her estate. As the afternoon sun bathes the garden in a warm, golden glow, And after waiting patiently for 30 mins as the model generated the sample, we get this\nTitle: \u0026quot;The Enigmatic Garden Murder\u0026quot; In the sleepy village of Willowbrook, nestled amidst rolling hills and lush greenery, a group of friends gather for their annual garden party. Lady Margaret Hastings, the elegant hostess known for her exquisite rose garden, has invited her closest friends and neighbors to revel in the beauty of her estate. As the afternoon sun bathes the garden in a warm, golden glow, a small, young man arrives in a beige chauffeur's car and picks up a young woman from the carousel. He smiles broadly and informs her that the afternoon's guests are all her relatives. They are not the sort of people she is used to seeing, however, and they demand to know where she is going. The young man reluctantly responds that she is going to the cottage of the Duke of Douglas. The Duchess appears with her husband at once, but when the young man insists on taking his leave, she hesitates. Despite her chagrin, she gives him the keys to the cottage and asks him to escort her out. Murdered: A Girl Who Loved the Water The young man emerges from the cottage in a raincoat and comes out into the alleyway with his mistress. They approach each other. \u0026quot;I should like to ask you something,\u0026quot; he says. \u0026quot;You're going to the cottage of the Duke of Douglas?\u0026quot; \u0026quot;Yes, I am.\u0026quot; \u0026quot;But what is the purpose for your visit?\u0026quot; \u0026quot;I want to find out more about the painting in the house. It was a gift from a friend of mine. He did not appreciate the painting quite as I do.\u0026quot; \u0026quot;He very nearly had it,\u0026quot; replied the maid. \u0026quot;He had an obstinate and irritable temper.\u0026quot; \u0026quot;But how could he have done it?\u0026quot; asked the young man anxiously. Dowager Margaret Hastings took a deep breath. \u0026quot;Well, he said it was too big and too much of a pain to take to get rid of it. He thought it too much like a picture that belonged to his parents. He said he would prefer to have it cleaned up. So he finally decided to destroy it.\u0026quot; \u0026quot;Is that all?\u0026quot; inquired the maid, incredulously. \u0026quot;But how?\u0026quot; \u0026quot;Oh, it's not so terrible,\u0026quot; replied Margaret Hastings with a smile. \u0026quot;It just took so long for him to kill the painting, and he was an old hand at that time, so he got in a little bit of trouble and had to meet with a certain fate.\u0026quot; \u0026quot;You mean, he got caught up in it?\u0026quot; asked the maid. \u0026quot;Surely you didn't mean to kill him in the first place, did you? Why would you do such a thing?\u0026quot; \u0026quot;Miss Bates, I was merely trying to amuse myself; you see, when the painting was at my disposal, I took it out and examined it closely, and I thought there was no danger to life or limb. But, as I said, the Duke of Douglas has a temper, and, as a result, he was very angry. Of course he pushed me aside and, when I tried to get away, he caught me up.\u0026quot; \u0026quot;That's all right, my dear lady. You don't see any danger in it?\u0026quot; \u0026quot;No, my dear Bates; it was simply a natural, even amusing thing that occurred. I didn't blame him for it. His temper was like mine. It's all right to be angry sometimes, and sometimes one is. In this case, it seems to me that he was quite justified. I had a pretty good instinct about such things; I knew the Duke of Douglas personally, and, of course, he was no friend of mine. He was a good man, a sensible man, and he knew he was not to blame for what had happened.\u0026quot; Douglas personally, and, of course, he was no friend of mine. He was a good man, a sensible man, and he knew he was not to blame for what had happened.\u0026quot; \u0026quot;And it was, indeed, your husband who had fallen into the trap?\u0026quot; asked the maid. \u0026quot;Did you say that he had fallen into the trap?\u0026quot; \u0026quot;Not the trap myself, Miss Bates. But the Duke of Douglas has the right to dispose of the painting.\u0026quot; \u0026quot;But why?\u0026quot; asked the maid in surprise. \u0026quot;Doesn't he have the right to dispose of the painting?\u0026quot; \u0026quot;Yes; he did have the right to dispose of it,\u0026quot; said Margaret Hastings with a gentle smile. \u0026quot;There are rules governing this matter, Miss Bates; one must be content if one possesses no means of disposing of a work of art because it is his--and somebody else's--property. There are no grounds for anger in this matter.\u0026quot; The maid began to tremble. \u0026quot;Oh, my God!\u0026quot; she cried. \u0026quot;You're quite right! I have never erred in my life. I really believe the Duke of Douglas is guilty of murder!\u0026quot; The maid's despair was quickly quelled. \u0026quot;I think,\u0026quot; said Margaret Hastings, \u0026quot;that your husband may have been justified. I really do. But that is the trouble: the Duke of Douglas has no right to dispose of the painting unless he has the right to dispose of it.\u0026quot; \u0026quot;But what of, Miss Bates?\u0026quot; This output is much much better and it actually does resemble her writing a lot even though it lacks overall structure to the story. For 10 iterations of finetuning, this isn\u0026rsquo;t bad at all. We can perhaps make this better by increasing the number of iterations in training or increasing batch_size but it might be a bit more computationally expensive to do so. Overall, it was a nice experiment and an interesting introduction to training and finetuning models.\n","date":"2023-10-04T14:24:06+05:30","image":"https://anoura12.github.io/blog/p/write-like-agatha-christie-using-nanogpt/agathabooks_hu3b064dde4729d41a24ae36393a586490_110863_120x120_fill_q75_box_smart1.jpg","permalink":"https://anoura12.github.io/blog/p/write-like-agatha-christie-using-nanogpt/","title":"Write like Agatha Christie using NanoGPT!"},{"content":"Large Language Models or LLMs are all the hype nowadays with ChatGPT now being a part of our everyday lives. Naturally, the curious lot of us would like to understand how these LLMs work under the hood and run these models ourselves. To effectively run an LLM, we would need numerous GPU servers to handle the load of inference and model training making it computationally expensive to do so.\nBut how expensive are we talking about here? For training models in particular, one of the fastest GPUs used is the A100 GPU. For reference, a single A100 GPU costs around $15,000. The Galactica model by Meta AI used 128 A100 GPUs for training. Along with high-end GPUs, it needs equally efficient CPUs. So, NVIDIA offers the DGX A100 which contains CPU compute power and 8 A100 GPUs which racks up to around $200,000. If we do the math, the total cost to fully train an LLM is a whopping $3.2 million. A little out of my price range if you ask me.\nThe more feasible way to access LLM capabiities is through APIs like the OpenAI API or online platforms that have these models deployed and open for public use. However, a new open source tool called Petals opens the possibility of running these models in your own computer right in the comfort of your home.\nWhat is it exactly? Petals is an open source tool created by the BigScience community backed by startup, Hugging Face. This novel tool allows you to run an LLM in your own system through shared GPU servers hosted across the world on other machines. (These servers are contributed by people who offer their system\u0026rsquo;s GPU for use.) You download a small part of the model on your machine while the other servers run other parts of the model for inference and fine-tuning. Think Bit-Torrent for LLMs.\nThis novel approach proves to be 10x faster than offloading (processes on a central server divided over multiple servers to increase speed and efficiency of the task) bringing about a more collaborative environment to train LLMs. Petals seeks to incentivise the process of contributing your system GPU where donators will receive “Bloom points” that they can spend on “higher priority or increased security guarantees” or potentially exchange for other rewards.\nWhat makes it so novel? The popular method to running LLMs before was offloading. Here\u0026rsquo;s how lead Petals developer, Alexander Borzunov described offloading - \u0026ldquo;Imagine you have an A100 GPU with 80 GB memory and want to generate text with BLOOM, a 70-block transformer model with ~2.5 GB of weights per block. For each token, offloading will load the first 1/3 of the model (~27 blocks) from RAM/SSD to your GPU memory, run a forward pass through them, then free the memory and load the next 2/3, and so on.\u0026rdquo;\nAs opposed to APIs, offloading provided a lot of control to the internal weights of the LLM which is great for researchers however, due to the data transfer (we\u0026rsquo;re talking about transfering the model weights here, so around 175 GB transferred to a GPU in three intervals just to generate one token!) from RAM to GPUs, it leads to pretty high latency. This is particularly not favourable for applications like chatbots that need quick responses and rely on low-latency mechanisms.\nPetals is able to do inference 10x faster than offloading because it passes the neural network activation values (intermediate values or outputs produced at each layer of a neural network during the forward pass that represent the model\u0026rsquo;s internal representations) rather than all the weights. This results in a much lower latency value which is perfect for building LLM applications. (Something to also note is that Petals does have a lower throughput than offloading)\nHow does it work? Petals works as a decentralised pipeline where a model is split into different blocks (transformer blocks) and hosted on different GPU servers. Each server holds consecutive blocks, the number of which depends on the server\u0026rsquo;s available GPU memory.\nOutput generation always takes place in an inference session. Before each inference session, the client is routed through a chain of servers that collectively holds models layers. Each server selects the most optimal set of blocks based on the current bottlenecks within the pipeline.\nIn the inference session, the client stores a model\u0026rsquo;s embeddings locally. It then searches embedding vectors on the prefix token of the query from the local embeddings and sends these vectors to the servers. The servers compute these vectors and the final block sends the model representations (neural network activation values) back to the client which then computes probabilities of the next token based on these representations. While the session is active, servers store attention keys and values from past client inputs and use them for subsequent inference steps. To address potential failures, a client stores intermediate activations sent to each block and reroutes them from an offline server to an online node hosting the same block.\nHow do you run it on your computer? It\u0026rsquo;s pretty simple to run Petals on your system. All you need to do is first install Petals\npip install git+https://github.com/bigscience-workshop/petals and then run the following code with your preferred open source LLM - this uses Stable Beluga 2 which a finetuned model of LLaMa 2.\nfrom transformers import AutoTokenizer from petals import AutoDistributedModelForCausalLM # Choose any model available at https://health.petals.dev model_name = \u0026quot;petals-team/StableBeluga2\u0026quot; # Connect to a distributed network hosting model layers tokenizer = AutoTokenizer.from_pretrained(model_name) model = AutoDistributedModelForCausalLM.from_pretrained(model_name) # Run the model as if it were on your computer inputs = tokenizer(\u0026quot;Cat in french is\u0026quot;, return_tensors=\u0026quot;pt\u0026quot;)[\u0026quot;input_ids\u0026quot;] outputs = model.generate(inputs, max_new_tokens=100) print(tokenizer.decode(outputs[0])) After running the code, you should get something like this. At the end, we can see the output, \u0026ldquo;Cat in french is chat.\u0026rdquo;\nThe line with Route found: 0:40 via ... shows that blocks 0 to 40 belong to a GPU server with id ending with HfQWVM and blocks 40 to 80 belong to another GPU server with id ending with Zj98Se. We can see these servers on the Petals health monitor as well. The prompt, \u0026ldquo;Cat in french is\u0026rdquo; got converted into embedding vectors which ran through these blocks and gave the final outcome as \u0026ldquo;Cat in french is chat.\u0026rdquo;\nOne thing to note is that it does take some time to generate the output from around 15-20 secs to well over a minute depending on the number of the max tokens and the complexity of the prompt. I\u0026rsquo;d say the main advantage that Petals offers over ChatGPT is that it\u0026rsquo;s free and you get more control over the model\u0026rsquo;s internal states to which different adapters can be fitted to finetune the model.\nA pressing question that may come up is how secure even is this thing? In theory, the inputs of the model that someone else has given could be accessed through the intermediate states between blocks. Additionally, these servers belong to other people who potentially could have access to private data sent as input to the model for it be computed on these servers. To address these issue, Petals has recommended organisations to build private swarms containing GPUs by people that they trust so that their data isn\u0026rsquo;t compromised.\nIn conclusion, I think Petals is great first step to decentralised compute for training LLMs. It opens a door of opportunities for those who can\u0026rsquo;t afford expensive GPUs to run these models which was earlier only restricted to rich corporations with the wherewithal to do so. I\u0026rsquo;m definitely excited to see what\u0026rsquo;s more to come.\n","date":"2023-09-25T14:33:30+05:30","image":"https://anoura12.github.io/blog/p/petals-a-game-changer-in-training-llms/petals_huac0153e0569e2ace21e9c0c4fd6908e8_139392_120x120_fill_box_smart1_2.png","permalink":"https://anoura12.github.io/blog/p/petals-a-game-changer-in-training-llms/","title":"Petals - A Game Changer in Training LLMs"},{"content":"GSoC 2021: Congratulations, your proposal with INCF has been accepted!  I honestly couldn’t believe it. Till 11:17 PM that day, I was ridden with anxiety but it was all worth it when I finally saw the awaited email. Hours spent in proposal writing, maintaining constant communication with the project leads and handling ongoing uncertainties until now finally paid off.\nThe 2 month long project involves building a working prototype of AutSPACEs - a citizen science, participatory platform for, with and by the autistic community. It aims to capture their experiences with sensory processing difficulties. It sends this information to scientists who can generate better datasets and urge policy-makers to design and adapt spaces better suited to an autistic person’s needs. (Hence the name, AutSPACEs)\nThe thing is, autism can’t be clearly categorised into separate levels. It’s different for everyone. That’s why making any advancements in this realm prove to be so difficult considering every individual has different needs and requirements. So, AutSPACEs reaches out to these autistic users to get information that is raw, authentic and true to each individual which scientists can rely on to get the best possible outcomes.\nAutSPACEs is developed using Python over a Django framework. It is connected to a backend database called Open Humans which is responsible for storing all the user experiences. Essentially, this database will be accessed through API calls where each user’s information will be stored as JSON data in a file. For the frontend, Bootstrap is being implemented to design the web pages with reference to simplified wireframes. The project has a lot of focus on the UI aspects as well because certain colours and layouts tend to trigger an autistic person’s senses. Hence, making the site as accessible as possible is a priority.\nThe project is currently in its early stages with the immediate goal of creating an MVP or a minimum viable product of the site. I’m really looking forward to helping the team achieve this!\nMy Google Summer of Code journey took off with the community bonding period. Right after my first interaction with my mentors, Kirstie Whitaker and Lotty Coupat, and the autistic community along with project lead, Georgia Aitkenhead and head developer, James Kim, I was absolutely delighted to be a part of this amazing team. The meetups and the community calls provide a really lively atmosphere to share ideas and collaborate with the moderators and the dev team to reach viable solutions.\nI can’t wait to see what’s in store for me in the next two months. To infinity and beyond!\n","date":"2021-06-25T18:46:43+05:30","image":"https://anoura12.github.io/blog/p/inception-google-summer-of-code-week-1/GSOC_hu7ceaa1e96e123523c8b348548cbddb61_66193_120x120_fill_q75_box_smart1.jpg","permalink":"https://anoura12.github.io/blog/p/inception-google-summer-of-code-week-1/","title":"Inception: Google Summer of Code - Week 1"}]